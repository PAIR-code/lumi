# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

import re
from mistletoe import Document, HtmlRenderer
from shared import import_tags


def parse_lumi_import(model_output_string: str) -> dict:
    """
    Parses a markdown string formatted with lumi-specific tags into a dictionary.

    Args:
        model_output_string: The input string generated by the model.

    Returns:
        A dictionary containing extracted sections:
        {'title': '...', 'authors': '...', 'abstract': '...',
         'content': '...', 'references': '...'}
        Keys will be present only if their corresponding tags are found.
    """
    parsed_data = {}

    # Define the regex pattern for each section.
    # re.DOTALL makes '.' match newlines, (.*?) makes it non-greedy.
    patterns = {
        "title": import_tags.L_TITLE_PATTERN,
        "authors": import_tags.L_AUTHORS_PATTERN,
        "abstract": import_tags.L_ABSTRACT_PATTERN,
        "content": import_tags.L_CONTENT_PATTERN,
        "references": import_tags.L_REFERENCES_PATTERN,
    }

    for key, pattern in patterns.items():
        match = re.search(pattern, model_output_string)
        if match:
            # Strip leading/trailing whitespace from the captured content
            parsed_data[key] = match.group(1).strip()
        # If a section is not found, the key is simply omitted from the dictionary,
        # which is often preferred over an empty string default.

    # Use re.finditer to get match objects, which allows accessing specific groups
    references_list = []
    if "references" in parsed_data:
        for match in re.finditer(
            import_tags.L_REFERENCE_ITEM_PATTERN, parsed_data["references"]
        ):
            ref_id = match.group(1)  # The N from reference-id-N
            ref_content = match.group(2).strip()  # The actual reference text
            references_list.append({"id": ref_id, "content": ref_content})

    parsed_data["references"] = references_list
    return parsed_data


def markdown_to_html(markdown: str) -> str:
    """
    Converts markdown text to an html string.

    Args:
        markdown (str): The markdown to convert.

    Returns:
        str: The converted html string.
    """
    markdown = markdown.replace("_", "\\_")
    markdown = markdown.replace("\\$", "\\\\$")
    with HtmlRenderer() as renderer:
        doc = Document(markdown)
        html = renderer.render(doc)
        return html


def postprocess_span_text(text: str) -> str:
    """
    Post-processes text right before it is finalized in a LumiSpan

    Args:
        text (str): The text to clean.

    Returns:
        str: The cleaned text.
    """
    # (1) Swaps $ in for escaped \\$
    text = text.replace("\\$", "$")
    # (2) Removing any remaining Lumi tags that were not correctly processed.
    text = re.sub(r"\[\[l-.*?\]\]", "", text)
    return text
